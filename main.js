import { Sandbox } from './wrapper/sandbox.js';
import path from 'path';
import { WebSocketServer } from 'ws';
import http from 'http';
import { spawn } from 'child_process';

// Stockage des sessions actives
const sessions = new Map();
const activeBridgeIds = new Map(); // Changed to Map to store timeout info
const connectedBridges = new Map(); // Track connected bridges and their info

// Fonction pour g√©n√©rer un ID de bridge unique
function generateBridgeId() {
    let bridgeId;
    do {
        // Generate a random 8-character hex string
        bridgeId = Math.random().toString(16).substring(2, 10);
    } while (activeBridgeIds.has(bridgeId));

    const expiresAt = Date.now() + 60000; // 1 minute from now

    // Set a 1-minute timeout for the bridge ID
    const timeout = setTimeout(() => {
        console.log(`\n‚åõ Bridge ID ${bridgeId} expired`);
        activeBridgeIds.delete(bridgeId);
    }, 60000); // 1 minute timeout

    // Store the bridge ID with its timeout and expiration time
    activeBridgeIds.set(bridgeId, {
        createdAt: Date.now(),
        expiresAt: expiresAt,
        timeout: timeout
    });

    return {
        bridgeId,
        expiresAt
    };
}

// Function to validate bridge ID
function validateBridgeId(bridgeId) {
    const bridgeInfo = activeBridgeIds.get(bridgeId);
    if (!bridgeInfo) {
        return false;
    }

    // Clear the timeout as the bridge ID is being used
    clearTimeout(bridgeInfo.timeout);
    activeBridgeIds.delete(bridgeId);
    return true;
}

// Fonction pour diffuser l'√©tat des connexions √† tous les clients
function broadcastConnections() {
    const connections = Array.from(sessions.entries()).map(([id, session]) => ({
        id,
        status: session.sandboxes.size > 0 ? 'running' : 'connected',
        startTime: session.startTime,
        scriptPath: session.sandboxes.size > 0 ? session.sandboxes.values().next().value.scriptPath : null,
    }));

    const message = JSON.stringify({
        type: 'connections_update',
        connections
    });

    sessions.forEach(session => {
        if (session.ws && session.ws.readyState === 1) { // 1 = OPEN
            session.ws.send(message);
        }
    });
}

// Function to broadcast bridge status to all clients
function broadcastBridgeStatus() {
    const bridgeStatus = Array.from(connectedBridges.entries()).map(([bridgeId, info]) => ({
        bridgeId,
        platform: info.platform,
        connectedAt: info.connectedAt,
        status: 'connected'
    }));

    const message = JSON.stringify({
        type: 'bridge_status_update',
        bridges: bridgeStatus
    });

    // Also notify clients about bridge IDs that are no longer expiring
    const bridgeValidationMessage = JSON.stringify({
        type: 'bridge_validation_update',
        validBridgeIds: Array.from(connectedBridges.keys())
    });

    sessions.forEach(session => {
        if (session.ws && session.ws.readyState === 1) {
            session.ws.send(message);
            session.ws.send(bridgeValidationMessage);
        }
    });
}

// Fonction pour arr√™ter proprement une sandbox
async function stopSandbox(sessionId, sandboxId = null) {
    const session = sessions.get(sessionId);
    if (session) {
        console.log(`\nüõë [DEBUG] D√©but de l'arr√™t - Session: ${sessionId}, Sandbox: ${sandboxId || 'toutes'}`);
        try {
            if (sandboxId) {
                // Arr√™ter une sandbox sp√©cifique
                if (session.sandboxes.has(sandboxId)) {
                    const sandboxInfo = session.sandboxes.get(sandboxId);
                    if (sandboxInfo.process) {
                        console.log(`\n[DEBUG] Informations du processus √† arr√™ter:`);
                        console.log(`- PID: ${sandboxInfo.process.pid}`);
                        console.log(`- Exit Code: ${sandboxInfo.process.exitCode}`);
                        console.log(`- Killed: ${sandboxInfo.process.killed}`);
                        console.log(`- Platform: ${process.platform}`);

                        try {
                            // Importer execSync au d√©but
                            const { execSync } = await import('child_process');
                            
                            // Lister tous les processus pour trouver les enfants
                            console.log(`[DEBUG] Recherche des processus enfants...`);
                            const wmic = `wmic process where (ParentProcessId=${sandboxInfo.process.process._handle.pid}) get ProcessId`;
                            console.log(`[DEBUG] Commande WMIC: ${wmic}`);
                            const childPids = execSync(wmic)
                                .toString()
                                .split('\n')
                                .slice(1) // Ignorer l'en-t√™te
                                .map(pid => pid.trim())
                                .filter(pid => pid); // Filtrer les lignes vides
                            
                            console.log(`[DEBUG] PIDs enfants trouv√©s:`, childPids);
                            
                            // Tuer chaque processus enfant
                            for (const childPid of childPids) {
                                try {
                                    const killCmd = `taskkill /F /T /PID ${childPid}`;
                                    console.log(`[DEBUG] Killing child process: ${killCmd}`);
                                    execSync(killCmd);
                                } catch (e) {
                                    console.error(`[DEBUG] Erreur lors de la tentative de kill du PID ${childPid}:`, e.message);
                                }
                            }

                            // Tuer le processus parent en dernier
                            const parentPid = sandboxInfo.process.process._handle.pid;
                            const parentCmd = `taskkill /F /T /PID ${parentPid}`;
                            console.log(`[DEBUG] Killing parent process: ${parentCmd}`);
                            execSync(parentCmd);
                            
                            console.log(`[DEBUG] Tous les processus ont √©t√© tu√©s`);
                        } catch (error) {
                            console.error(`\n[DEBUG] Erreur lors de l'arr√™t du processus:`, error);
                        }
                    } else {
                        console.log(`\n[DEBUG] Pas de processus trouv√© pour la sandbox ${sandboxId}`);
                    }
                    session.sandboxes.delete(sandboxId);
                    
                    // Envoyer le message de mise √† jour
                    if (session.ws && session.ws.readyState === 1) {
                        session.ws.send(JSON.stringify({
                            type: 'sandbox_updated',
                            connectionId: sessionId,
                            sandbox: {
                                id: sandboxId,
                                isRunning: false
                            }
                        }));
                    }
                } else {
                    console.log(`\n[DEBUG] Sandbox ${sandboxId} non trouv√©e`);
                }
            } else {
                // Arr√™ter toutes les sandboxes de la session
                if (session.sandboxes.size > 0) {
                    for (const [sandboxId, sandboxInfo] of session.sandboxes) {
                        if (sandboxInfo.process) {
                            try {
                                // Importer execSync au d√©but
                                const { execSync } = await import('child_process');
                                
                                // Lister tous les processus pour trouver les enfants
                                console.log(`[DEBUG] Recherche des processus enfants...`);
                                const wmic = `wmic process where (ParentProcessId=${sandboxInfo.process.process._handle.pid}) get ProcessId`;
                                console.log(`[DEBUG] Commande WMIC: ${wmic}`);
                                const childPids = execSync(wmic)
                                    .toString()
                                    .split('\n')
                                    .slice(1) // Ignorer l'en-t√™te
                                    .map(pid => pid.trim())
                                    .filter(pid => pid); // Filtrer les lignes vides
                                
                                console.log(`[DEBUG] PIDs enfants trouv√©s:`, childPids);
                                
                                // Tuer chaque processus enfant
                                for (const childPid of childPids) {
                                    try {
                                        const killCmd = `taskkill /F /T /PID ${childPid}`;
                                        console.log(`[DEBUG] Killing child process: ${killCmd}`);
                                        execSync(killCmd);
                                    } catch (e) {
                                        console.error(`[DEBUG] Erreur lors de la tentative de kill du PID ${childPid}:`, e.message);
                                    }
                                }

                                // Tuer le processus parent en dernier
                                const parentPid = sandboxInfo.process.process._handle.pid;
                                const parentCmd = `taskkill /F /T /PID ${parentPid}`;
                                console.log(`[DEBUG] Killing parent process: ${parentCmd}`);
                                execSync(parentCmd);
                                
                                console.log(`[DEBUG] Tous les processus ont √©t√© tu√©s`);
                            } catch (error) {
                                console.error(`\n[DEBUG] Erreur lors de l'arr√™t du processus:`, error);
                            }
                        }
                    }
                    session.sandboxes.clear();
                    
                    // Envoyer le message de mise √† jour
                    if (session.ws && session.ws.readyState === 1) {
                        session.ws.send(JSON.stringify({
                            type: 'sandbox_updated',
                            connectionId: sessionId,
                            sandbox: null
                        }));
                    }
                }
            }
            console.log(`\n[DEBUG] Fin de l'arr√™t - Session: ${sessionId}, Sandbox: ${sandboxId || 'toutes'}`);
            broadcastConnections();
        } catch (error) {
            console.error(`\n[DEBUG] Erreur globale lors de l'arr√™t:`, error);
        }
    } else {
        console.log(`\n[DEBUG] Session ${sessionId} non trouv√©e`);
    }
}

// Gestion des signaux pour l'arr√™t propre
process.on('SIGINT', () => {
    console.log('\n‚ö†Ô∏è Signal SIGINT re√ßu');
    for (const sessionId of sessions.keys()) {
        stopSandbox(sessionId);
    }
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\n‚ö†Ô∏è Signal SIGTERM re√ßu');
    for (const sessionId of sessions.keys()) {
        stopSandbox(sessionId);
    }
    process.exit(0);
});

// Cr√©er le serveur HTTP
const server = http.createServer();
const wss = new WebSocketServer({ server });

// Gestion des connexions WebSocket
wss.on('connection', (ws) => {
    const sessionId = Date.now().toString();
    console.log(`\nüîå Nouvelle connexion WebSocket (session ${sessionId})`);

    // Stocker la session
    sessions.set(sessionId, { 
        ws, 
        sandboxes: new Map(), // Map des sandboxes actives
        startTime: new Date(),
    });

    // Envoyer l'√©tat initial des connexions
    broadcastConnections();

    // Gestion des messages
    ws.on('message', async (message) => {
        try {
            const data = JSON.parse(message);
            console.log(`\nüì® Message re√ßu pour la session ${sessionId}:`, JSON.stringify(data, null, 2));

            switch (data.type) {
                case 'generate_bridge_id': {
                    const { bridgeId, expiresAt } = generateBridgeId();
                    console.log(`\nüîë Generated bridge ID: ${bridgeId}, expires at: ${new Date(expiresAt).toISOString()}`);
                    ws.send(JSON.stringify({
                        type: 'bridge_id_generated',
                        bridgeId,
                        requestId: data.requestId,
                        expiresAt
                    }));
                    break;
                }

                case 'bridge_register': {
                    if (!data.bridgeId || !validateBridgeId(data.bridgeId)) {
                        ws.send(JSON.stringify({
                            type: 'error',
                            error: 'Invalid or expired bridge ID'
                        }));
                        // Close the connection for invalid bridge IDs
                        ws.close();
                        return;
                    }
                    
                    // Store bridge connection info
                    connectedBridges.set(data.bridgeId, {
                        platform: data.platform || 'unknown',
                        connectedAt: Date.now(),
                        ws: ws
                    });

                    console.log(`\nüîó Bridge registered with ID: ${data.bridgeId}, Platform: ${data.platform || 'unknown'}`);
                    ws.send(JSON.stringify({
                        type: 'bridge_registered',
                        bridgeId: data.bridgeId
                    }));

                    // Broadcast updated bridge status to all clients
                    broadcastBridgeStatus();
                    break;
                }

                case 'register_handler': {
                    // Handle registration of message handlers
                    console.log(`\nüìù Registering handler for session ${sessionId}`);
                    ws.send(JSON.stringify({
                        type: 'handler_registered',
                        success: true
                    }));
                    break;
                }

                case 'start':
                    // D√©marrer une nouvelle sandbox
                    if (!data.config || !data.config.scriptPath) {
                        throw new Error('Chemin du script requis');
                    }

                    console.log(`\nüöÄ D√©marrage de la sandbox pour la session ${sessionId}`);
                    console.log(`üìÅ Chemin du script: ${data.config.scriptPath}`);
                    console.log(`‚öôÔ∏è Variables d'environnement:`, data.config.env || {});

                    const sandbox = new Sandbox(data.config.scriptPath, data.config.env || {});
                    const bridge = sandbox.getBridge();

                    // Configuration des handlers du bridge
                    bridge
                        .onStdout(async ({ message }) => {
                            console.log(`\nüì§ [Session ${sessionId}] stdout:`, message);
                            ws.send(JSON.stringify({
                                type: 'stdout',
                                connectionId: sessionId,
                                sandboxId: data.sandboxId,
                                message
                            }));
                            return true;
                        })
                        .onStderr(async ({ message }) => {
                            console.log(`\nüì§ [Session ${sessionId}] stderr:`, message);
                            ws.send(JSON.stringify({
                                type: 'stderr',
                                connectionId: sessionId,
                                sandboxId: data.sandboxId,
                                message
                            }));
                            return true;
                        })
                        .onError(async ({ source, error }) => {
                            console.log(`\n‚ùå [Session ${sessionId}] Erreur (${source}):`, error);
                            ws.send(JSON.stringify({
                                type: 'error',
                                connectionId: sessionId,
                                sandboxId: data.sandboxId,
                                source,
                                error: error.message
                            }));
                        });

                    // D√©marrer le script
                    console.log(`\n‚ñ∂Ô∏è Ex√©cution du script pour la session ${sessionId}`);
                    sandbox.runScript(data.config.scriptPath).then(process => {
                        console.log(`\n[DEBUG] Processus d√©marr√©. PID: ${process.pid}`);
                        
                        // Stocker la sandbox imm√©diatement
                        const session = sessions.get(sessionId);
                        console.log(`\n[DEBUG] === D√âBUT ENREGISTREMENT SANDBOX ===`);
                        console.log(`[DEBUG] Session ID: ${sessionId}`);
                        console.log(`[DEBUG] Sandbox ID: ${data.sandboxId}`);
                        console.log(`[DEBUG] Session existe: ${!!session}`);
                        console.log(`[DEBUG] √âtat actuel des sandboxes:`, Array.from(session.sandboxes.keys()));
                        
                        // Cr√©er l'objet sandbox
                        const sandboxInfo = {
                            sandbox,
                            process,
                            scriptPath: data.config.scriptPath,
                            env: data.config.env || {},
                            isRunning: true
                        };

                        // Enregistrer la sandbox
                        session.sandboxes.set(data.sandboxId, sandboxInfo);
                        
                        // V√©rifier que la sandbox est bien enregistr√©e
                        console.log(`[DEBUG] Sandbox enregistr√©e. Nouvel √©tat:`, Array.from(session.sandboxes.keys()));
                        console.log(`[DEBUG] V√©rification de l'enregistrement:`, session.sandboxes.has(data.sandboxId));
                        console.log(`[DEBUG] Contenu de la sandbox:`, JSON.stringify(sandboxInfo, null, 2));
                        console.log(`[DEBUG] === FIN ENREGISTREMENT SANDBOX ===\n`);

                        // V√©rification finale
                        console.log(`[DEBUG] V√©rification finale - Sandbox toujours pr√©sente:`, session.sandboxes.has(data.sandboxId));
                        console.log(`[DEBUG] √âtat final des sandboxes:`, Array.from(session.sandboxes.keys()));

                        console.log(`\n‚úÖ Script d√©marr√© pour la session ${sessionId}`);
                        ws.send(JSON.stringify({
                            type: 'sandbox_updated',
                            connectionId: sessionId,
                            sandbox: {
                                id: data.sandboxId,
                                scriptPath: data.config.scriptPath,
                                env: data.config.env,
                                isRunning: true
                            }
                        }));
                        broadcastConnections();
                    }).catch(error => {
                        console.error(`\n‚ùå Erreur lors du d√©marrage du script:`, error);
                        ws.send(JSON.stringify({
                            type: 'error',
                            connectionId: sessionId,
                            error: error.message
                        }));
                    });
                    break;

                case 'stop':
                    // Arr√™ter la sandbox
                    console.log(`\nüõë Arr√™t demand√© pour la session ${sessionId}`);
                    const currentSession = sessions.get(sessionId);
                    console.log(`\n[DEBUG] √âtat des sandboxes avant arr√™t:`, Array.from(currentSession.sandboxes.keys()));
                    
                    if (currentSession && currentSession.sandboxes.has(data.sandboxId)) {
                        console.log(`\n[DEBUG] Sandbox ${data.sandboxId} trouv√©e, d√©but de l'arr√™t`);
                        const sandboxInfo = currentSession.sandboxes.get(data.sandboxId);
                        if (sandboxInfo.process) {
                            try {
                                // Importer execSync au d√©but
                                const { execSync } = await import('child_process');
                                
                                // Lister tous les processus pour trouver les enfants
                                console.log(`[DEBUG] Recherche des processus enfants...`);
                                const wmic = `wmic process where (ParentProcessId=${sandboxInfo.process.process._handle.pid}) get ProcessId`;
                                console.log(`[DEBUG] Commande WMIC: ${wmic}`);
                                const childPids = execSync(wmic)
                                    .toString()
                                    .split('\n')
                                    .slice(1) // Ignorer l'en-t√™te
                                    .map(pid => pid.trim())
                                    .filter(pid => pid); // Filtrer les lignes vides
                                
                                console.log(`[DEBUG] PIDs enfants trouv√©s:`, childPids);
                                
                                // Tuer chaque processus enfant
                                for (const childPid of childPids) {
                                    try {
                                        const killCmd = `taskkill /F /T /PID ${childPid}`;
                                        console.log(`[DEBUG] Killing child process: ${killCmd}`);
                                        execSync(killCmd);
                                    } catch (e) {
                                        console.error(`[DEBUG] Erreur lors de la tentative de kill du PID ${childPid}:`, e.message);
                                    }
                                }

                                // Tuer le processus parent en dernier
                                const parentPid = sandboxInfo.process.process._handle.pid;
                                const parentCmd = `taskkill /F /T /PID ${parentPid}`;
                                console.log(`[DEBUG] Killing parent process: ${parentCmd}`);
                                execSync(parentCmd);
                                
                                console.log(`[DEBUG] Tous les processus ont √©t√© tu√©s`);
                            } catch (error) {
                                console.error(`\n[DEBUG] Erreur lors de l'arr√™t du processus:`, error);
                            }
                        }
                        currentSession.sandboxes.delete(data.sandboxId);
                        console.log(`\n[DEBUG] Sandbox supprim√©e. √âtat final:`, Array.from(currentSession.sandboxes.keys()));
                        
                        ws.send(JSON.stringify({
                            type: 'sandbox_updated',
                            connectionId: sessionId,
                            sandbox: {
                                id: data.sandboxId,
                                isRunning: false
                            }
                        }));
                    } else {
                        console.log(`\n[DEBUG] Sandbox ${data.sandboxId} non trouv√©e pour la session ${sessionId}`);
                        console.log(`[DEBUG] Sandboxes disponibles:`, Array.from(currentSession.sandboxes.keys()));
                    }
                    broadcastConnections();
                    break;

                case 'command':
                    // Envoyer une commande au processus
                    const commandSession = sessions.get(sessionId);
                    if (commandSession && commandSession.sandboxes.has(data.sandboxId)) {
                        const sandboxInfo = commandSession.sandboxes.get(data.sandboxId);
                        if (sandboxInfo.process && sandboxInfo.process.stdin) {
                            console.log(`\nüìù Commande re√ßue pour la session ${sessionId}:`, data.command);
                            
                            // Formater la commande en JSON-RPC 2.0
                            const jsonRpcRequest = {
                                jsonrpc: "2.0",
                                method: data.command,
                                params: {},
                                id: Date.now()
                            };

                            console.log('\n[DEBUG] Envoi de la commande JSON-RPC:', JSON.stringify(jsonRpcRequest, null, 2));
                            sandboxInfo.process.stdin.write(JSON.stringify(jsonRpcRequest) + '\n');
                            
                            ws.send(JSON.stringify({
                                type: 'command_sent',
                                connectionId: sessionId,
                                sandboxId: data.sandboxId
                            }));
                        } else {
                            console.log('\n[DEBUG] √âtat du processus:');
                            console.log('- sandboxInfo.process existe:', !!sandboxInfo.process);
                            if (sandboxInfo.process) {
                                console.log('- Structure du processus:', JSON.stringify({
                                    hasStdin: !!sandboxInfo.process.stdin,
                                    processKeys: Object.keys(sandboxInfo.process)
                                }, null, 2));
                            }
                            throw new Error('Le processus n\'est pas pr√™t √† recevoir des commandes');
                        }
                    } else {
                        throw new Error('Sandbox non trouv√©e');
                    }
                    break;

                case 'stdout':
                case 'stderr':
                    const sandboxId = data['sandboxId'];
                    const message = data['message'];
                    const isJson = data['isJson'] || false;
                    
                    // Transmettre le message au client
                    if (sessions.get(sessionId).ws && sessions.get(sessionId).ws.readyState === 1) {
                        sessions.get(sessionId).ws.send(JSON.stringify({
                            type: data.type,
                            connectionId: sessionId,
                            sandboxId: sandboxId,
                            message: message,
                            isJson: isJson
                        }));

                        // Si c'est une r√©ponse JSON, mettre √† jour l'√©tat de la sandbox
                        if (isJson) {
                            try {
                                const jsonResponse = JSON.parse(message);
                                const sandbox = sessions.get(sessionId).sandboxes.find(
                                    (s) => s.id === sandboxId
                                );
                                if (sandbox) {
                                    sandbox.lastResponse = jsonResponse;
                                    // Notifier le client de la mise √† jour
                                    sessions.get(sessionId).ws.send(JSON.stringify({
                                        type: 'sandbox_response_updated',
                                        connectionId: sessionId,
                                        sandboxId: sandboxId,
                                        response: jsonResponse
                                    }));
                                }
                            } catch (e) {
                                console.error('Erreur lors du parsing de la r√©ponse JSON:', e);
                            }
                        }
                    }
                    break;

                case 'get_bridge_status': {
                    const bridgeStatus = Array.from(connectedBridges.entries()).map(([bridgeId, info]) => ({
                        bridgeId,
                        platform: info.platform,
                        connectedAt: info.connectedAt,
                        status: 'connected'
                    }));

                    ws.send(JSON.stringify({
                        type: 'bridge_status_update',
                        bridges: bridgeStatus
                    }));
                    break;
                }

                default:
                    console.log(`\n‚ö†Ô∏è Type de message non reconnu pour la session ${sessionId}:`, data.type);
                    throw new Error('Type de message non reconnu');
            }
        } catch (error) {
            console.error(`\n‚ùå Erreur pour la session ${sessionId}:`, error);
            ws.send(JSON.stringify({
                type: 'error',
                error: error.message
            }));
        }
    });

    // Handle bridge disconnection
    ws.on('close', () => {
        console.log(`\nüîå D√©connexion WebSocket (session ${sessionId})`);
        
        // Check if this was a bridge connection
        for (const [bridgeId, info] of connectedBridges.entries()) {
            if (info.ws === ws) {
                console.log(`\nüîå Bridge ${bridgeId} disconnected`);
                connectedBridges.delete(bridgeId);
                broadcastBridgeStatus();
                break;
            }
        }
        
        stopSandbox(sessionId);
    });
});

// D√©marrer le serveur
const PORT = 3000;
server.listen(PORT, () => {
    console.log(`\nüöÄ Bridge d√©marr√© sur le port ${PORT}`);
    console.log(`üìä Sessions actives: ${sessions.size}`);
}); 